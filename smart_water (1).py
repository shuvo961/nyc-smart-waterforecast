# -*- coding: utf-8 -*-
"""smart_water.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tqtR2UN0nTu_r1O8mWc3K02qYYepvOeS
"""

from google.colab import files
uploaded = files.upload()

import pandas as pd
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error
import xgboost as xgb
import numpy as np

# Step 1: Load dataset
df = pd.read_csv('/content/Water_Consumption_And_Cost__2013_-_Feb_2025__20250506.csv')

# Step 2: Clean and prepare
df = df[['Revenue Month', 'Current Charges']]
df.columns = ['date', 'charges']
df = df.dropna()
df['date'] = pd.to_datetime(df['date'], errors='coerce')
df = df.dropna()
df_monthly = df.groupby('date').mean().reset_index()

# Step 3: Feature Engineering
df_monthly['month'] = df_monthly['date'].dt.month
df_monthly['year'] = df_monthly['date'].dt.year
X = df_monthly[['month', 'year']]
y = df_monthly['charges']

# Step 4: Train/Test Split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

# Step 5: Model Training
model = xgb.XGBRegressor()
model.fit(X_train, y_train)
y_pred = model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
print(f'MSE: {mse:.2f}')

# Step 6: Create Future Dates (with valid month/year logic)
last_month = df_monthly['month'].iloc[-1]
last_year = df_monthly['year'].iloc[-1]
if last_month == 12:
    next_month = 1
    next_year = last_year + 1
else:
    next_month = last_month + 1
    next_year = last_year

future_months = pd.date_range(f'{next_year}-{next_month:02d}-01', periods=12, freq='MS')
future_df = pd.DataFrame({
    'date': future_months,
    'month': future_months.month,
    'year': future_months.year
})
future_pred = model.predict(future_df[['month', 'year']])
forecast_df = future_df.copy()
forecast_df['predicted_charges'] = future_pred

# Step 7: Plot
plt.figure(figsize=(12, 6))
plt.plot(df_monthly['date'], y, label='Historical')
plt.plot(forecast_df['date'], forecast_df['predicted_charges'], label='Forecast', linestyle='--')
plt.xlabel("Date")
plt.ylabel("Water Charges")
plt.title("Water Cost Forecast (XGBoost)")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

!pip install prophet --quiet

import pandas as pd
import matplotlib.pyplot as plt
from prophet import Prophet
from datetime import datetime

import pandas as pd

# Load the dataset (adjust filename if needed)
df = pd.read_csv('/content/Water_Consumption_And_Cost__2013_-_Feb_2025__20250506.csv')

# View column names
df.columns

# Show first 5 rows
df.head(10)

# Normalize column names
df.columns = [col.lower().strip().replace(" ", "_") for col in df.columns]

# Rename columns for clarity if present
if 'revenue_month' in df.columns and 'current_charges' in df.columns:
    df.rename(columns={'revenue_month': 'date', 'current_charges': 'cost'}, inplace=True)
else:
    raise KeyError("Required columns 'revenue_month' and 'current_charges' not found!")

# Convert to datetime and drop rows with missing values
df['date'] = pd.to_datetime(df['date'], errors='coerce')
df = df[['date', 'cost']].dropna()

# Group by month and sum costs
df_monthly = df.groupby(df['date'].dt.to_period('M'))['cost'].sum().reset_index()
df_monthly['date'] = df_monthly['date'].dt.to_timestamp()

# Final format for Prophet
df_prophet = df_monthly.rename(columns={'date': 'ds', 'cost': 'y'})

# View cleaned data
df_prophet.head()

import matplotlib.pyplot as plt

plt.figure(figsize=(12, 5))
plt.plot(df_prophet['ds'], df_prophet['y'], marker='o')
plt.title("NYC Water Cost (2013–2025)")
plt.xlabel("Year")
plt.ylabel("Monthly Cost ($)")
plt.grid(True)
plt.show()

# Check top 10 highest monthly totals
df_prophet.sort_values('y', ascending=False).head(10)

# Remove outliers above a threshold (e.g., $1 million)
threshold = 1_000_000
df_filtered = df_prophet[(df_prophet['y'] < threshold) & (df_prophet['ds'].dt.year <= 2025)]

plt.figure(figsize=(12, 5))
plt.plot(df_filtered['ds'], df_filtered['y'], marker='o')
plt.title("NYC Water Cost (2013–2025) Without Outliers")
plt.xlabel("Year")
plt.ylabel("Monthly Cost ($)")
plt.grid(True)
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import matplotlib.ticker as ticker

# Plot without outliers above $1 million
threshold = 1_000_000
df_filtered = df_prophet[(df_prophet['y'] < threshold) & (df_prophet['ds'].dt.year <= 2025)]

plt.figure(figsize=(12, 5))
plt.plot(df_filtered['ds'], df_filtered['y'], marker='o')

plt.title("NYC Water Cost (2013–2025)")
plt.xlabel("Year")
plt.ylabel("Monthly Cost ($)")
plt.grid(True)

# Format y-axis with dollar format
ax = plt.gca()
ax.yaxis.set_major_formatter(ticker.StrMethodFormatter('${x:,.0f}'))

plt.tight_layout()
plt.show()

# Use 'date' (formerly 'revenue_month') and 'cost' (formerly 'current_charges')

# Check for required columns
if 'borough' in df.columns and 'date' in df.columns and 'cost' in df.columns:
    # Filter data: valid borough, date, and cost
    df_borough = df[['borough', 'date', 'cost']].dropna()

    # Group by borough to get total cost
    borough_summary = df_borough.groupby('borough')['cost'].sum().sort_values(ascending=False)

    # Display result
    print(borough_summary)
else:
    print("Required columns 'borough', 'date', or 'cost' not found.")

import matplotlib.pyplot as plt
import matplotlib.ticker as ticker

# Ensure consistent column names
df.columns = [col.lower().strip().replace(" ", "_") for col in df.columns]

# Rename if not already done
df.rename(columns={
    'revenue_month': 'date',
    'current_charges': 'cost'
}, inplace=True)

# Check and filter valid entries
if 'borough' in df.columns and 'date' in df.columns and 'cost' in df.columns:
    df_borough = df[['borough', 'date', 'cost']].dropna()

    # Group by borough
    borough_summary = df_borough.groupby('borough')['cost'].sum().sort_values(ascending=False)

    # Plot
    plt.figure(figsize=(10, 5))
    borough_summary.plot(kind='bar', color='lightgreen')

    plt.title("Total Water Cost by Borough (2013–2025)")
    plt.xlabel("Borough")
    plt.ylabel("Total Cost ($)")
    plt.grid(axis='y')

    # Format y-axis as currency
    ax = plt.gca()
    ax.yaxis.set_major_formatter(ticker.StrMethodFormatter('${x:,.0f}'))

    plt.tight_layout()
    plt.show()
else:
    print("Missing one or more required columns: 'borough', 'date', 'cost'.")

print(df.columns)

import pandas as pd

# Reload raw dataset
df_raw = pd.read_csv('/content/Water_Consumption_And_Cost__2013_-_Feb_2025__20250506.csv')

# Normalize column names
df_raw.columns = [col.lower().strip().replace(" ", "_") for col in df_raw.columns]

# Extract relevant columns again
df_borough = df_raw[['borough', 'revenue_month', 'current_charges']].dropna()

# Rename columns
df_borough.rename(columns={
    'revenue_month': 'date',
    'current_charges': 'cost'
}, inplace=True)

# Convert date
df_borough['date'] = pd.to_datetime(df_borough['date'], errors='coerce')
df_borough = df_borough[df_borough['date'].dt.year <= 2025]

# Group and summarize cost by borough
borough_summary = df_borough.groupby('borough')['cost'].sum().sort_values(ascending=False)

# Plotting
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker

plt.figure(figsize=(10, 5))
borough_summary.plot(kind='bar', color='cornflowerblue')
plt.title("Total Water Cost by Borough (2013–2025)")
plt.xlabel("Borough")
plt.ylabel("Total Cost ($)")
plt.grid(axis='y')

# Format as currency
ax = plt.gca()
ax.yaxis.set_major_formatter(ticker.StrMethodFormatter('${x:,.0f}'))

plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import matplotlib.ticker as ticker

# Ensure 'year' column exists
df_borough['year'] = df_borough['date'].dt.year

# Get unique years
years = sorted(df_borough['year'].dropna().unique())

# Plot for each year
for year in years:
    yearly_data = df_borough[df_borough['year'] == year]
    borough_summary = yearly_data.groupby('borough')['cost'].sum().sort_values(ascending=False)

    # Create figure
    plt.figure(figsize=(8, 4))
    borough_summary.plot(kind='bar', color='mediumseagreen')

    plt.title(f"Total Water Cost by Borough - {year}")
    plt.xlabel("Borough")
    plt.ylabel("Total Cost ($)")
    plt.grid(axis='y')

    ax = plt.gca()
    ax.yaxis.set_major_formatter(ticker.StrMethodFormatter('${x:,.0f}'))

    plt.tight_layout()
    plt.show()

from prophet import Prophet

# Use your cleaned cost DataFrame (from earlier)
# This assumes df_prophet has columns: ds (date), y (cost)
# If not, reconstruct from original data:

df_cost = df_raw[['revenue_month', 'current_charges']].dropna()
df_cost.rename(columns={'revenue_month': 'ds', 'current_charges': 'y'}, inplace=True)
df_cost['ds'] = pd.to_datetime(df_cost['ds'], errors='coerce')
df_cost = df_cost[df_cost['ds'].dt.year <= 2025]
df_cost = df_cost.groupby(df_cost['ds'].dt.to_period('M'))['y'].sum().reset_index()
df_cost['ds'] = df_cost['ds'].dt.to_timestamp()

model = Prophet()
model.fit(df_cost)

# Forecast 12 months ahead (Jan–Dec 2026)
future = model.make_future_dataframe(periods=12, freq='MS')
forecast = model.predict(future)

# Filter for 2026
forecast_2026 = forecast[forecast['ds'].dt.year == 2026]
total_cost_2026 = forecast_2026['yhat'].sum()

print(f"💰 Estimated total water cost for 2026: ${total_cost_2026:,.2f}")

# Convert revenue_month
df_raw['revenue_month'] = pd.to_datetime(df_raw['revenue_month'], errors='coerce')

# Clean consumption data
df_consump = df_raw[['borough', 'revenue_month', 'consumption_(hcf)']].dropna()
df_consump.rename(columns={'revenue_month': 'date', 'consumption_(hcf)': 'consumption'}, inplace=True)
df_consump['year'] = df_consump['date'].dt.year

# Filter only up to 2025
df_consump = df_consump[df_consump['year'] <= 2025]

# Aggregate: total consumption per borough per year
yearly_borough = df_consump.groupby(['year', 'borough'])['consumption'].sum().reset_index()

import pandas as pd

# Reload original dataset if needed
df_raw = pd.read_csv('/content/Water_Consumption_And_Cost__2013_-_Feb_2025__20250506.csv')

# Normalize column names
df_raw.columns = [col.lower().strip().replace(" ", "_") for col in df_raw.columns]

# Extract required columns
df_costs = df_raw[['borough', 'revenue_month', 'current_charges']].dropna()
df_costs.rename(columns={'revenue_month': 'date', 'current_charges': 'cost'}, inplace=True)
df_costs['date'] = pd.to_datetime(df_costs['date'], errors='coerce')
df_costs = df_costs[df_costs['date'].dt.year.between(2013, 2025)]

# Add year column
df_costs['year'] = df_costs['date'].dt.year

# Group by year and borough
yearly_borough_costs = df_costs.groupby(['year', 'borough'])['cost'].sum().reset_index()

# Loop through years and print formatted output
for year in sorted(yearly_borough_costs['year'].unique()):
    print(f"📅 Water Cost by Borough for {year}:")

    yearly_df = yearly_borough_costs[yearly_borough_costs['year'] == year]
    yearly_df = yearly_df.sort_values(by='cost', ascending=False)

    total = 0
    for _, row in yearly_df.iterrows():
        print(f"  {row['borough']:<14} → ${row['cost']:,.2f}")
        total += row['cost']

    print(f"  {'Total':<14} → ${total:,.2f}")
    print("-" * 50)

import matplotlib.pyplot as plt
import matplotlib.ticker as ticker

# Add year column (if not already)
df_costs['year'] = df_costs['date'].dt.year

# Group by year and borough
yearly_costs = df_costs.groupby(['year', 'borough'])['cost'].sum().unstack()

# Plot
plt.figure(figsize=(12, 6))
yearly_costs.plot(marker='o', figsize=(12, 6))

plt.title("📈 Total Annual Water Cost by Borough (2013–2025)")
plt.xlabel("Year")
plt.ylabel("Annual Water Cost ($)")
plt.grid(True)

# Format y-axis as dollars
ax = plt.gca()
ax.yaxis.set_major_formatter(ticker.StrMethodFormatter('${x:,.0f}'))

plt.legend(title="Borough")
plt.tight_layout()
plt.show()

from sklearn.linear_model import LinearRegression
import numpy as np
import pandas as pd

# Rate per HCF (adjust as needed)
rate_per_hcf = 3.50

# Predict 2026 consumption for each borough and convert to dollars
predictions = []

for borough in yearly_borough['borough'].unique():
    df_b = yearly_borough[yearly_borough['borough'] == borough]

    X = df_b[['year']]
    y = df_b['consumption']

    model = LinearRegression()
    model.fit(X, y)

    # Predict 2026
    pred_hcf = model.predict(np.array([[2026]]))[0]
    pred_dollars = pred_hcf * rate_per_hcf

    predictions.append((borough, pred_hcf, pred_dollars))

# Create result DataFrame
pred_df = pd.DataFrame(predictions, columns=['borough', 'predicted_hcf_2026', 'predicted_cost_2026'])
pred_df = pred_df.sort_values(by='predicted_cost_2026', ascending=False)

# Compute total
total_cost = pred_df['predicted_cost_2026'].sum()

# Display full table
print("📊 Predicted Borough Water Cost for 2026:")
print(pred_df.to_string(index=False, formatters={
    'predicted_hcf_2026': '{:,.2f}'.format,
    'predicted_cost_2026': '${:,.2f}'.format
}))

# Display total
print(f"\n💰 Total Predicted Water Cost (All Boroughs) for 2026: ${total_cost:,.2f}")

# Display top borough
top_borough = pred_df.iloc[0]
print(f"🏆 Borough expected to have highest water cost: {top_borough['borough']} with ${top_borough['predicted_cost_2026']:,.2f}")

# Append 2026 predictions to the historical DataFrame
pred_2026 = pred_df[['borough', 'predicted_cost_2026']]
pred_2026['year'] = 2026
pred_2026 = pred_2026.rename(columns={'predicted_cost_2026': 'cost'})

# Combine with historical cost data
df_2026 = pred_2026[['year', 'borough', 'cost']]
df_historic = df_costs[['year', 'borough', 'cost']]
df_combined = pd.concat([df_historic, df_2026], ignore_index=True)

# Group and pivot again
yearly_combined = df_combined.groupby(['year', 'borough'])['cost'].sum().unstack()

import matplotlib.pyplot as plt
import matplotlib.ticker as ticker

# Plot full data including prediction
plt.figure(figsize=(12, 6))
ax = yearly_combined.plot(marker='o', figsize=(12, 6), linestyle='-', linewidth=2)

# Highlight 2026 with dashed markers
for borough in yearly_combined.columns:
    if 2026 in yearly_combined.index:
        y_val = yearly_combined.loc[2026, borough]
        ax.plot(2026, y_val, 'o--', label=f"{borough} (2026)", markersize=8)

plt.title("📈 Annual Water Cost by Borough (2013–2026 Including Forecast)")
plt.xlabel("Year")
plt.ylabel("Annual Cost ($)")
plt.grid(True)

# Format y-axis as currency
ax.yaxis.set_major_formatter(ticker.StrMethodFormatter('${x:,.0f}'))

plt.legend(title="Borough", bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

from sklearn.ensemble import IsolationForest

# Prepare data (monthly borough-level cost)
df_anomaly = df_costs.copy()
df_anomaly['month'] = df_anomaly['date'].dt.to_period('M')
monthly_borough = df_anomaly.groupby(['month', 'borough'])['cost'].sum().reset_index()
monthly_borough['month'] = monthly_borough['month'].dt.to_timestamp()

# Pivot to borough-wise time series
pivot_df = monthly_borough.pivot(index='month', columns='borough', values='cost').fillna(0)

# Fit Isolation Forest
model = IsolationForest(contamination=0.05, random_state=42)
pivot_df['anomaly_score'] = model.fit_predict(pivot_df)

# Mark anomalies
pivot_df['is_anomaly'] = pivot_df['anomaly_score'] == -1

# Plot anomalies
import matplotlib.pyplot as plt

plt.figure(figsize=(12, 6))
plt.plot(pivot_df.index, pivot_df.drop(['anomaly_score', 'is_anomaly'], axis=1).sum(axis=1), label='Total Cost')
plt.scatter(pivot_df[pivot_df['is_anomaly']].index,
            pivot_df[pivot_df['is_anomaly']].drop(['anomaly_score', 'is_anomaly'], axis=1).sum(axis=1),
            color='red', label='Anomaly')
plt.title("Anomaly Detection in Total Water Cost")
plt.xlabel("Month")
plt.ylabel("Total Monthly Cost ($)")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# Define parameters
base_consumption = 5000  # HCF
rate_per_hcf = 3.5

# Ask user
change = float(input("Enter percentage change in your water usage (e.g., -10 for 10% decrease): "))
new_consumption = base_consumption * (1 + change / 100)
new_cost = new_consumption * rate_per_hcf

print(f"\n📊 Simulated Result:")
print(f"Original Cost: ${base_consumption * rate_per_hcf:,.2f}")
print(f"New Cost after {change:.1f}% change: ${new_cost:,.2f}")

from sklearn.ensemble import IsolationForest
import pandas as pd

# Prepare monthly cost per borough
df_costs['month'] = df_costs['date'].dt.to_period('M')
monthly_borough = df_costs.groupby(['month', 'borough'])['cost'].sum().reset_index()
monthly_borough['month'] = monthly_borough['month'].dt.to_timestamp()

# Pivot table for model input (each borough is a feature)
pivot_df = monthly_borough.pivot(index='month', columns='borough', values='cost').fillna(0)
pivot_df.head()

# Train Isolation Forest model
iso_model = IsolationForest(n_estimators=100, contamination=0.05, random_state=42)
pivot_df['anomaly_score'] = iso_model.fit_predict(pivot_df)

# Mark anomaly
pivot_df['is_anomaly'] = pivot_df['anomaly_score'] == -1
pivot_df.tail()

import matplotlib.pyplot as plt

# Total cost across all boroughs
pivot_df['total_cost'] = pivot_df.drop(['anomaly_score', 'is_anomaly'], axis=1).sum(axis=1)

plt.figure(figsize=(12, 6))
plt.plot(pivot_df.index, pivot_df['total_cost'], label='Total Monthly Cost', color='blue')
plt.scatter(
    pivot_df[pivot_df['is_anomaly']].index,
    pivot_df[pivot_df['is_anomaly']]['total_cost'],
    color='red',
    label='Anomaly',
    zorder=5
)
plt.title("💥 Anomaly Detection in NYC Monthly Water Cost (2013–2025)")
plt.xlabel("Month")
plt.ylabel("Total Cost ($)")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

# Clean base consumption dataset
df_raw.columns = [col.lower().strip().replace(" ", "_") for col in df_raw.columns]
df_raw['revenue_month'] = pd.to_datetime(df_raw['revenue_month'], errors='coerce')

# Filter relevant data
df_usage = df_raw[['borough', 'revenue_month', 'consumption_(hcf)']].dropna()
df_usage = df_usage[df_usage['revenue_month'].dt.year <= 2025]

# Calculate average monthly consumption per borough
borough_avg = df_usage.groupby('borough')['consumption_(hcf)'].mean().reset_index()
borough_avg.columns = ['borough', 'avg_monthly_hcf']
borough_avg

# Normalize borough names in the DataFrame
borough_avg['borough'] = borough_avg['borough'].str.strip().str.lower()

# Take user input and normalize
selected_borough = input("Enter borough name (e.g., Queens, Brooklyn, Manhattan): ").strip().lower()

# Check if the input is valid
if selected_borough not in borough_avg['borough'].values:
    print("❌ Borough not found. Please check spelling.")
else:
    # Get base HCF
    base_hcf = borough_avg.loc[borough_avg['borough'] == selected_borough, 'avg_monthly_hcf'].values[0]
    print(f"📊 Average Monthly Usage in {selected_borough.title()}: {base_hcf:.2f} HCF")

    # Get percentage change
    change_percent = float(input("Enter % change in usage (e.g., -10 for 10% decrease, 20 for increase): "))
    new_hcf = base_hcf * (1 + change_percent / 100)

    rate_per_hcf = 3.50
    original_cost = base_hcf * rate_per_hcf
    new_cost = new_hcf * rate_per_hcf

    # Output
    print(f"\n💧 Simulated Water Usage Impact in {selected_borough.title()}")
    print(f"Original Monthly Cost: ${original_cost:,.2f}")
    print(f"New Monthly Cost after {change_percent:+.1f}% change: ${new_cost:,.2f}")

# Forecast for 2026 (from Prophet)
forecast_2026[['ds', 'yhat']].to_csv("forecast_2026.csv", index=False)

# Borough-level prediction (from linear regression)
pred_df.to_csv("borough_predictions_2026.csv", index=False)

# Anomaly output (from Isolation Forest)
pivot_df[['total_cost', 'is_anomaly']].reset_index().to_csv("anomaly_detection.csv", index=False)

# Historical costs
yearly_costs.to_csv("borough_costs_2013_2025.csv")